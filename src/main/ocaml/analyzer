#!/usr/bin/env python
'''Recurrence complexity analyzer '''
import sys
from os import listdir
import numpy as np 
import pandas as pd 
import seaborn as sns 
import matplotlib.pyplot as plt 
from sklearn import preprocessing, svm 
from sklearn.model_selection import train_test_split 
from sklearn.linear_model import LinearRegression 

class RecRel:
    def __init__(self, a: int, coef: float):
        self.a = a
        self.coef = coef

class Node:
    def __init__(self, d: int, a: int, val: float):
        self.d = d
        self.a = a
        self.val = val

def calc_coefs(queue, coefs, num_rec_calls):
    # get parent node
    p_index = len(queue)-1-num_rec_calls
    if (p_index < 0):
        return coefs
    parent = queue[p_index]
     
    if len(coefs) == 0:
        coefs = [[] for i in range(num_rec_calls)]
    ls = range(num_rec_calls-1, -1, -1)
    for i in ls:
        child = queue.pop()
        if (child.val != float(0)):
            coefs[i].append(float(parent.val) / float(child.val))

    # print("coef: ", coefs)
    # print("queue: ", [q.val for q in queue])
    # print("parent: ", parent.val)
    count = 1
    prev = parent
    for i in range(1, num_rec_calls, 1):
        index = len(queue) - 1 - i
        if index < 0:
            break
        node = queue[index]
        if prev.d == node.d:
            count += 1
        prev = node

    if count == num_rec_calls:
        calc_coefs(queue, coefs, num_rec_calls)
    return coefs

def get_cur_node(line: str):
    # each line has the following format: depth;a;n
    m = line.rstrip('\n').split(';')
    m = [int(m[0]), int(m[1]), m[2]]
    return Node(m[0], m[1], float(m[2]))

def get_num_rec_calls(lines: list):
    max_depth, nums = 0, 1
    prev = Node(-1, 1, 0.0)
    for i, line in enumerate(lines):
        # print(line)
        cur = get_cur_node(line)
        if cur.d < prev.d:
            return nums
        if (prev.d <= cur.d and len(lines) - 1 > i):
            if max_depth < cur.d:
                max_depth = cur.d
                nums = 1
            if prev.d == cur.d and cur.d == max_depth:
                nums += 1
        prev = cur          
    return nums

def read_logs(filename: str):
    with open(filename) as file:
        #print("reading from ", filename)
        lines = file.readlines()
        num_rec_calls = get_num_rec_calls(lines)
        # print(filename)
        # print(num_rec_calls)
        queue, coefs = [], []
        prev  = Node(-1, 1, 0.0)
        for i, line in enumerate(lines):
            # print(line)
            cur = get_cur_node(line)
            # find the bottom of the branch
            if (prev.d <= cur.d and len(lines) - 1 != i):
                prev = cur          
                queue.append(cur)
                continue
            # calculate coefs for the current branch
            coefs = calc_coefs(queue, coefs, num_rec_calls)
            queue.append(cur)
            prev = cur          
        #print(coefs)
    file.close()
    return coefs

dir_name = sys.argv[1]

filenames = [f for f in listdir(dir_name)]
final_coefs = []
for filename in filenames:
    # print("analyzing a file: ", filename)
    coefs = read_logs(dir_name + filename)
    if len(final_coefs) == 0:
        final_coefs = coefs
    # print(coefs)
    # print("finished analyzing a file: ", filename)
    # print(len(coefs))
    for i, coef in enumerate(coefs):
        # print("coef: ", coef)
        final_coefs[i].extend([c for c in coef])
# print(final_coefs)

# print([type(c) for c in final_coefs[0]])
# print(final_coefs)

print("simple average: ")
 # + " + " + str(np.average(np.array(final_coefs[1])))
for i in range(len(final_coefs)):
    print(str(np.average(np.array(final_coefs[i]))))


print("-------------")

x = [i for i,v in enumerate(final_coefs[0])]
rec_relations = []

for coefs in final_coefs:
    data = np.array([x, coefs])
    #print(data)
    #columns=['','node id','coefs']
    df = pd.DataFrame(list(zip(x, coefs)), 
                   columns =['node ids', 'coefs']) 
    #df = pd.DataFrame(data=data, index=['node id','coefs'], columns=x)
    # df.head()
    #sns.lmplot(x ="node id", y ="coefs", data = df, order = 2, ci = None)

    X = np.array(df['node ids']).reshape(-1, 1) 
    y = np.array(df['coefs']).reshape(-1, 1)

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.25)
    regr = LinearRegression() 
      
    regr.fit(X_train, y_train) 
    # print(regr.score(X_test, y_test))

    y_pred = regr.predict(X_test)
    plt.scatter(X_test, y_test, color ='b') 
    plt.plot(X_test, y_pred, color ='k') 
      
    # plt.show()
    rec_relations.append(RecRel(1, np.average(y_pred)))
# rec_relations[0].coef
print("Recurrent relation is ")
for i in range(len(final_coefs)):
    print(str(rec_relations[i].a) + "*T(n/" + str(int(rec_relations[i].coef)) + ")")
